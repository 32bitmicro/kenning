# Copyright (c) 2025 Antmicro <www.antmicro.com>
#
# SPDX-License-Identifier: Apache-2.0

"""
Provides tools to generate ai8x model source code.
"""

import itertools
import re
from pathlib import Path
from typing import Iterable, Optional, Tuple

from kenning.utils.logger import KLogger

# regex patterns
CNN_LOAD_BIAS_RE_PATTERN = r"""
int\ cnn_load_bias\(void\).*?\{(.*?)\}
"""

TARGETS_RE_PATTERN = r"""
memcpy_8to32\(.*?(0x[0-9a-fA-F]*?)\s*,\s*.*?,.*?\)
"""

KERNELS_RE_PATTERN = r"""
\#define\ KERNELS\ \{(.*?)\}
"""

BIASES_RE_PATTERN = r"""
\#define\ BIAS_\d*\ \{(.*?)\}
"""

LOAD_INPUT_RE_PATTERN = r"""
void\ load_input\(void\).*?
\{
(.*?)  # memcpys
\}
"""

INPUTS_RE_PATTERN = r"""
memcpy32\(.*?
(0x[0-9a-fA-F]*?)  # target address
\s*,\s*.*?,\s*
(\d*)  # length
\s*\)
"""

CNN_INIT_RE_PATTERN = r"""
int\ cnn_init\(.*?\).*?\{.*?\}
"""

CNN_CONFIGURE_RE_PATTERN = r"""
int\ cnn_configure\(.*?\).*?\{.*?\}
"""

CNN_UNLOAD_RE_PATTERN = r"""
int\ cnn_unload\(.*?\).*?\{.*?\}
"""

OUT_BUF_RE_PATTERN = r"""
(uint\d*?_t)\s*\*out_buf\s*=\s*\(\s*uint\d*_t\s*\*\s*\)\s*out_buf32
"""

# c source templates
CNN_MODEL_C_TEMPLATE = r"""
#include <stdint.h>

#define CNN_OK 0
#define CNN_ERR 1

static int32_t min(int32_t a, int32_t b) {{
    return a < b ? a : b;
}}

static void memcpy32(uint32_t * dst, uint32_t * src, uint32_t n) {{
    for (uint32_t i = 0; i < n; i++) {{
        dst[i] = src[i];
    }}
}}

{cnn_init}

{cnn_configure}

{cnn_unload}

{cnn_load_input}
"""

INPUT_CHECK_C_TEMPLATE = r"""
        if (off < {coff}) {{
            uint32_t to_write = min({coff} - off, n);
            memcpy32(
                (uint32_t *)0x{offset:08x} + (off - {coff_sub_length}),
                src,
                to_write
            );
            n -= to_write;
            off += to_write;
            continue;
        }}
"""

CNN_LOAD_INPUT_C_TEMPLATE = r"""
int cnn_load_input(uint32_t * src, uint32_t off, uint32_t n) {{
    while (n > 0) {{
{checks_str}
        return -1;
    }}
    return 0;
}}
"""


def generate_model_bin(
    cnn_path: Path,
    weights_path: Path,
    output_path: Path,
):
    """
    Generates binary with model weights.

    Parameters
    ----------
    cnn_path : Path
        Path to the cnn source file generated by ai8x-synthesis.
    weights_path : Path
        Path to the weights header file generated by ai8x-synthesis.
    output_path : Path
        Path to the output file, where model weights will be saved.
    """
    cnn_str = cnn_path.read_text()
    weights_str = weights_path.read_text()

    weights_str = weights_str.replace("\\", "")

    cnn_load_bias_re = re.compile(CNN_LOAD_BIAS_RE_PATTERN, re.X | re.S)
    targets_re = re.compile(TARGETS_RE_PATTERN, re.X | re.S)
    kernels_re = re.compile(KERNELS_RE_PATTERN, re.X | re.S)
    biases_re = re.compile(BIASES_RE_PATTERN, re.X | re.S)

    cnn_load_bias = _extract_next_func(cnn_str, cnn_load_bias_re)

    targets = targets_re.findall(cnn_load_bias)

    kernels = kernels_re.search(weights_str).group(1)
    kernels_int = [int(x, base=16) for x in kernels.split(",")]

    biases = biases_re.findall(weights_str)
    biases_int = [
        [int(x, base=16) for x in bias.strip().split(",")] for bias in biases
    ]

    model_chunks = [kernels_int]

    for bias_target, bias in zip(targets, biases_int):
        model_chunks.append(
            [
                int(bias_target, base=16),
                len(bias),
                *bias,
                0,
            ]
        )

    model_int = list(itertools.chain(*model_chunks))
    model_bytes = b"".join(
        x.to_bytes(length=4, byteorder="little") for x in model_int
    )

    output_path.write_bytes(model_bytes)

    KLogger.debug(f"Model weights saved in: {output_path}")


def generate_model_source(
    main_path: Path,
    cnn_path: Path,
    output_path: Path,
):
    """
    Generates model source.

    Parameters
    ----------
    main_path : Path
        Path to the main source file generated by ai8x-synthesis.
    cnn_path : Path
        Path to the cnn source file generated by ai8x-synthesis.
    output_path : Path
        Path to the output file, where model source will be saved.
    """
    main_str = main_path.read_text()
    cnn_str = cnn_path.read_text()

    load_input_re = re.compile(LOAD_INPUT_RE_PATTERN, re.X | re.S)
    inputs_re = re.compile(INPUTS_RE_PATTERN, re.X | re.S)
    cnn_init_re = re.compile(CNN_INIT_RE_PATTERN, re.X | re.S)
    cnn_configure_re = re.compile(CNN_CONFIGURE_RE_PATTERN, re.X | re.S)
    cnn_unload_re = re.compile(CNN_UNLOAD_RE_PATTERN, re.X | re.S)
    out_buf_re = re.compile(OUT_BUF_RE_PATTERN, re.X | re.S)

    load_input = _extract_next_func(main_str, load_input_re)
    inputs = inputs_re.findall(load_input)

    cnn_init = _extract_next_func(cnn_str, cnn_init_re)
    cnn_configure = _extract_next_func(cnn_str, cnn_configure_re)
    cnn_unload = _extract_next_func(cnn_str, cnn_unload_re)

    out_buf = out_buf_re.search(cnn_unload)
    if out_buf is not None:
        cnn_unload = cnn_unload.replace(
            out_buf.group(0),
            out_buf.group(0).replace(out_buf.group(1), "uint8_t"),
        )

    cnn_load_input = _generate_model_source_load_input(inputs)

    cnn_model_c_str = CNN_MODEL_C_TEMPLATE.format(
        cnn_init=cnn_init,
        cnn_configure=cnn_configure,
        cnn_unload=cnn_unload,
        cnn_load_input=cnn_load_input,
    )

    output_path.write_text(cnn_model_c_str)

    KLogger.debug(f"Model source saved in: {output_path}")


def _extract_next_block(source: str) -> str:
    """
    Extracts c code block from provided source.

    Parameters
    ----------
    source : str
        Provided c source.

    Returns
    -------
    str
        Extracted block.
    """
    OPEN_BRACE = "{"
    CLOSE_BRACE = "}"

    start_idx = source.find(OPEN_BRACE)
    if start_idx < 0:
        return None

    depth = 1
    length = 1

    for c in source[start_idx + 1 :]:
        if c == OPEN_BRACE:
            depth += 1
        elif c == CLOSE_BRACE:
            depth -= 1

        length += 1

        if depth == 0:
            break

    return source[start_idx : start_idx + length]


def _extract_next_func(source: str, pattern: re.Pattern[str]) -> Optional[str]:
    """
    Extracts function from c source using given pattern.

    Parameters
    ----------
    source : str
        Given c source.
    pattern : re.Pattern[str]
        Function pattern.

    Returns
    -------
    Optional[str]
        Extracted function if found, None otherwise.
    """
    res = pattern.search(source)

    if res is None:
        return None

    trim = source[res.start() :]
    decl, *bs = trim.partition("{")
    block = _extract_next_block("".join(bs))
    return "".join([decl, block])


def _generate_model_source_load_input(
    input_tab: Iterable[Tuple[str, str]],
) -> str:
    """
    Generates model input loading source.

    Parameters
    ----------
    input_tab: Iterable[Tuple[str, str]]
        Iterable with inputs offset and lengths.

    Returns
    -------
    str
        Generated load model input source.
    """
    checks = []
    coff = 0

    for offset, length in input_tab:
        length = int(length)
        offset = int(offset, base=16)
        coff += length
        checks.append(
            INPUT_CHECK_C_TEMPLATE.format(
                coff=coff,
                offset=offset,
                length=length,
                coff_sub_length=(coff - length),
            )
        )

    checks_str = "\n".join(checks)
    result = CNN_LOAD_INPUT_C_TEMPLATE.format(checks_str=checks_str)

    return "\n".join(
        filter(None, map(lambda x: x.strip("\r\n"), result.splitlines()))
    )
